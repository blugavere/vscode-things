{"Test Controller Method":{"prefix":"test:ctrl:method","body":["     describe('$1', () => {","       it('should $1', done => {","         service.$1.yields(null, {});","         ctrl.$1(req, res);","         setImmediate(() => {","           expect(res.send.called).toBe(true, 'res.send never called');","           expect(res.status.calledWith(200)).toBe(true, 'incorrect error code');","           done();","         });","       });","","       it('should fail gracefully', done => {","         service.$1.yields({});","         ctrl.$1(req, res);","         setImmediate(() => {","           expect(res.send.called).toBe(true, 'res.send never called');","           expect(res.status.calledWith(400)).toBe(true, 'incorrect error code');","           done();","         });","       });","","     });",""]},"Test Service Method":{"prefix":"test:service:method","body":["     describe('$1', () => {","       it('should $1', done => {","         repo.$1.yields(null, {})","         service.$1('foo', (err, res) => {","           expect(err).toNotExist('expected no error to be thrown');","           expect(res).toExist('expected cb to return a result');","           done();","         });","       });","","       it('should fail gracefully', done => {","         repo.$1.yields({})","         service.$1('foo', err => {","           expect(err).toExist('expected error to exist in cb');","           done();","         });","       });","","     });",""]},"Test Repository Method":{"prefix":"test:repo:method","body":["     describe('$1', () => {","       it('should $1', done => {","         Mockgoose.find.yields(null, {})","         repo.$1('foo', (err, res) => {","           expect(err).toNotExist('expected no error to be thrown');","           expect(res).toExist('expected cb to return a result');","           done();","         });","       });","","       it('should fail gracefully', done => {","         Mockgoose.find.yields({})","         repo.$1('foo', err => {","           expect(err).toExist('expected error to exist in cb');","           done();","         });","       });","","     });",""]},"Test Injection Method":{"prefix":"test:inject:method","body":["     describe('Dependency Injection Support', () => {","       it('should implement di container spec', done => {","         expect($1.inject).toExist('expected prop inject to exist');","         expect(Array.isArray($1.inject)).toBe(true, 'expected di static to return an array');","         done();","       });","","     });",""]},"React Component Test":{"prefix":"test:component","body":["","'use strict';","","const expect = require('expect');","const sinon = require('sinon');","const React = require('react');","const shallow = require('enzyme').shallow;","","const setup = () => {","\tconst props = {","\t//define props here","\t};"," return shallow(<Component {...props} />);","};","","describe('<Component />', () => {","","let component","","beforeEach(() => {","\tcomponent = setup();","});","","describe('Component Feature', () => {","","\tit('should pass', () => {","\t\texpect(true).toBe(true);","\t});","","\tit('should also pass', done => {","\t\texpect(true).toBe(true);","\t\tdone();","\t});","","});","","});","","// examples: ","// component.find(DialogActions).childAt(0).simulate('click');","// expect(wrapper.find(DialogActions).childAt(1).childAt(0).text()).toEqual('Cancel');","// expect(component.find(DialogTitle).childAt(0).text()).toEqual('foo');"]},"Redux Action Test":{"prefix":"test:actions","body":["","const expect = require('expect');","const sinon = require('sinon');","import * as actions from './actions';","import * as types from './constants';","import configureMockStore from 'redux-mock-store';","import thunk from 'redux-thunk';","","const middlewares = [thunk];","const mockStore = configureMockStore(middlewares);","","","describe('Component Actions', () => {","\tlet store;","","\tbefore(() => {","\tstore = mockStore();","\t});","","\tafter(() => {","","\t});","","\tbeforeEach(() => {","","\t});","","\tbeforeEach(() => {","\t\tstore.clearActions();","\t});","","\tdescribe('Component Feature', () => {","","\t\tit('should pass', () => {","\t\t\texpect(true).toBe(true);","\t\t});","","\t\tit('should also pass', done => {","\t\t\texpect(true).toBe(true);","\t\t\tdone();","\t\t});","","\t});","","});",""]},"docs:findAll":{"prefix":"docs:findAll","body":["   docs.add('$1', docFactory.get()","       .description('Find All $1s')","       .summary('Find All')","       .setModel('$1')","       .idParam()","       .onSuccess(200, {","           description: 'Response',","           schema: Doc.arrayOf(Doc.model('$1'))","       })","       .build());"]},"docs:findOne":{"prefix":"docs:findOne","body":["   docs.add('/$1/findOne/{id}', docFactory.get()","       .description('Find One $1')","       .summary('Find One')","       .setModel('$1')","       .idParam()","       .onSuccess(200, {","           description: 'Response',","           schema: Doc.model('$1')","       })","       .build());"]},"swagger:findAll":{"prefix":"swagger:post","body":["    /**","     * @swagger","     * /v1/ROUTE:","     *   get:","     *     tags:","     *       - $1s","     *     description: Find All $1s","     *     produces:","     *       - application/json","     *     responses:","     *         200:","     *             description: New $1","     *             schema:","     *                 \\$ref: '#/definitions/$1","\t */"]},"swagger:post":{"prefix":"swagger:post","body":["    /**","     * @swagger","     * /v1/ROUTE:","     *   post:","     *     tags:","     *       - $1s","     *     description: Create $1","     *     produces:","     *       - application/json","     *     parameters:","     *       - name: $1","     *         description: $1 object","     *         in: body","     *         required: true","     *         schema:","     *           \\$ref: '#/definitions/$1'","     *     responses:","     *       201:","     *         description: New $1","     *         schema:","     *           \\$ref: '#/definitions/$1","\t */"]},"Route Setup":{"prefix":"route","body":["","'use strict';","","","const types = require(''); // path to types","","const register = (app, injector) => {","\tconst ctrl = injector.get(types.$1Ctrl);","","\tapp.get('/model', ctrl.findAll);","};","","module.exports = register;",""]},"Unit Test Setup":{"prefix":"test","body":["","'use strict';","","const path = require('path');","const expect = require('expect');","const sinon = require('sinon');","","const mock = {","};","","/**","* helper: ${TM_FILEPATH}","* mocha --require clarify ./path/to/file.test.js --watch","* istanbul cover --print both node_modules/.bin/_mocha -- ./path/to/file.test.js","* eslint ./path/to/file.test.js --watch","*/","","describe(path.basename(__filename).replace('.test.js', ''), () => {","\tlet sandbox;","","\tbefore(() => {","","\t});","","\tafter(() => {","","\t});","","\tbeforeEach(() => {","\t\tsandbox = sinon.sandbox.create();","\t});","","\tafterEach(() => {","\t\tsandbox.restore();","\t});","","\tit('should pass', () => {","\t\texpect(true).toBe(true);","\t});","","\tit('should also pass', done => {","\t\texpect(true).toBe(true);","\t\tdone();","\t});","});",""]},"Integration Test Setup":{"prefix":"integration:test","body":["","'use strict';","","const path = require('path');","const expect = require('expect');","const sinon = require('sinon');","const assert = require('assert');","const mongoose = require('mongoose');","","const types = require('');","const Mocks = require('');","const chalk = require('chalk');","const app = { set() {} };","const mock = {","};","","/**","* helper: ${TM_FILEPATH}","* mocha --require clarify $2 --watch","* istanbul cover --print both node_modules/.bin/_mocha -- $2","* eslint $2","*/","","describe('$1 Integration Test', () => {","\tlet sandbox;","\tlet req = Mocks.req;","\tlet res = Mocks.res;","\tlet ctrl;","\tlet repo;","\tlet injector;","","\tbefore(() => {","\t\trequire('../../models/plugins/autoincr').init();","\t\trequire('../../models/loadModels');","\t\tinjector = require('').default.configure(app);","\t\tctrl = injector.get(types.$1Ctrl);","\t\trepo = injector.get(types.$1Repository);","\t\tmongoose.connect('mongodb://localhost/giddy-test');","\t});","","\tafter(() => {","\t\tmongoose.models = {};","\t\tmongoose.modelSchemas = {};","\t\tmongoose.connection.models = {};","\t\tmongoose.disconnect();","\t});","","\tbeforeEach(() => {","\t\tsandbox = sinon.sandbox.create();","\t\tsandbox.stub(res);","\t\tsandbox.stub(req);","\t});","","\tafterEach(() => {","\t\tsandbox.restore();","\t});","","\tdescribe('queries', () => {","\t\tit('should be able to find a $1', done => {","\t\t\trepo.findOne('id', (err, doc) => {","\t\t\t\texpect(doc).toExist('expected $1 to exist');","\t\t\t\tdone();","\t\t\t});","\t\t});","\t});","","\tdescribe('routes', () => {","\t\tafterEach(() => {","\t\t\texpect(res.send.called).toBe(true, 'res.send never called');","\t\t});","","\t\tit('should do something', done => {","\t\t\treq.body = {};","\t\t\tctrl.method(req, res); //EDIT","\t\t\tsetTimeout(() => {","\t\t\t\texpect(res.status.calledWith(200)).toBe(true, 'res.status called with wrong status code');","\t\t\t\tdone();","\t\t\t}, 100);","\t\t});","\t});","","});",""]},"Repository":{"prefix":"repository","body":["","'use strict';","","const types = require('');","const MongooseRepository = require('../repositories/base/MongooseRepository');","","function populate(queryable) {","    return queryable;","}","","class $1Repository extends MongooseRepository {","    static get inject(){","        return [","            types.$1","        ];","    }","    constructor(model) {","        super(model);","","        this.findOneDetailed = this.findOneDetailed.bind(this);","    }","    findOneDetailed(id, cb) {","        cb();","    }","","}","","module.exports = $1Repository;",""]},"Repository Test Setup":{"prefix":"repository:test","body":["","'use strict';","","const path = require('path');","const expect = require('expect');","const sinon = require('sinon');","const _ = require('lodash');","const Mockgoose = require('../repositories/base/Mockgoose');","const Repository = require('./$1Repository');","","/**","* helper: ${TM_FILEPATH}","* mocha --require clarify $2 --watch","* istanbul cover --print both node_modules/.bin/_mocha -- $2","* eslint $2","*/","","describe('$1Repository', () => {","\tlet sandbox;","\tlet repo;","","\tbeforeEach(() => {","\t\tsandbox = sinon.sandbox.create();","\t\tfor (const i in Mockgoose) {","\t\t\tsandbox.stub(Mockgoose, i);","\t\t}","\t\tMockgoose.populate.returns(Mockgoose);","\t\tMockgoose.lean.returns(Mockgoose);","\t\trepo = new Repository(Mockgoose);","\t});","","\tafterEach(() => {","\t\tsandbox.restore();","\t});","","\tdescribe('general', () => {","\t\tit('should have an injection static', () => {","\t\t\texpect(Array.isArray(Repository.inject)).toBe(true);","\t\t});","\t});","","\tdescribe('$1 business methods', () => {","\t\tit('should pass', () => {","\t\t\texpect(true).toBe(true);","\t\t});","","\t\tit('should also pass', done => {","\t\t\texpect(true).toBe(true);","\t\t\tdone();","\t\t});","\t});","});",""]},"Service":{"prefix":"service","body":["","'use strict';","","const types = require('');","","class $1Service {","    static get inject(){","        return [","            types.$1Repository","        ];","    }","    constructor(repo) {","        this.repo = repo;","","        this.findOne = this.findOne.bind(this);","    }","    findOne(id, cb) {","        cb();","    }","","}","","module.exports = $1Service;",""]},"Service Method":{"prefix":"service:test:method","body":["describe('$1', () => {","\tit('should $1', done => {","\t\trepo.findOne.yields(null, {});","\t\tservice.$1('foo', (err, doc) => {","\t\t\texpect(err).toNotExist();","\t\t\texpect(doc).toExist();","\t\t\tdone();","\t\t});","\t});","","\tit('should fail gracefully', done => {","\t\trepo.findOne.yields({});","\t\tservice.$1('foo', err => {","\t\t\texpect(err).toExist();","\t\t\tdone();","\t\t});","\t});","});"]},"Service Test Setup":{"prefix":"service:test","body":["","'use strict';","","const expect = require('expect');","const sinon = require('sinon');","const $1Service = require('./$1Service');","","const repo = Object.assign({}, require('../repositories/base/MockRepo'), {","\tfindOneDetailed(){}","});","","/**","* helper: ${TM_FILEPATH}","* mocha --require clarify $2 --watch","* istanbul cover --print both node_modules/.bin/_mocha -- $2","* eslint $2","*/","","describe('$1Service', () => {","\tlet sandbox;","\tlet service;","","\tbeforeEach(() => {","\t\tsandbox = sinon.sandbox.create();","\t\tsandbox.stub(repo);","\t\tservice = new $1Service(repo);","\t});","","\tafterEach(() => {","\t\tsandbox.restore();","\t});","","\tdescribe('general', () => {","\t\tit('should have an injection static', () => {","\t\t\texpect(Array.isArray($1Service.inject)).toBe(true);","\t\t});","\t});","","\tdescribe('$1 Service Methods', () => {","\t\tit('should pass', () => {","\t\t\texpect(true).toBe(true);","\t\t});","","\t\tit('should also pass', done => {","\t\t\texpect(true).toBe(true);","\t\t\tdone();","\t\t});","\t});","});",""]},"Factory":{"prefix":"factory","body":["","'use strict';","","const types = require('');","","class $1Factory {","    static get inject(){","        return [","            types.$1","        ];","    }","","    constructor($1) {","        this.$1 = $1;","        this.create = this.create.bind(this);","        this.reconstitute = this.reconstitute.bind(this);","    }","    create(data, cb) {","\t\t\t\tconst model = Object.assign(new this.$1(), data);","       cb(null, model);","    }","","    reconstitute(data, cb) {","\t\t\t\tconst model = Object.assign(new this.$1(), data);","       cb(null, model);","\t }","}","","module.exports = $1Factory;",""]},"Factory Test Setup":{"prefix":"factory:test","body":["","'use strict';","","","const expect = require('expect');","const sinon = require('sinon');","const $1Factory = require('./$1Factory');","","/**","* helper: ${TM_FILEPATH}","* mocha --require clarify ./path/to/file.test.js --watch","* istanbul cover --print both node_modules/.bin/_mocha -- ./path/to/file.test.js","* eslint ./path/to/file.test.js --watch","*/","","describe('$1Factory', () => {","\tlet sandbox;","\tlet factory;","\tlet data;","\tlet Model = function(){};","","\tbeforeEach(() => {","\t\tsandbox = sinon.sandbox.create();","\t\tfactory = new $1Factory(Model);","\t});","","\tafterEach(() => {","\t\tsandbox.restore();","\t});","","\tdescribe('general', () => {","\t\tit('should have an injection static', () => {","\t\t\texpect(Array.isArray($1Factory.inject)).toBe(true);","\t\t});","\t});","","\tdescribe('$1 Factory Methods', () => {","\t\tdescribe('create', () => {","\t\t\tit('should create a $1', done => {","\t\t\t\tfactory.create(data, (err, res) => {","\t\t\t\t\texpect(res).toExist('expected factory to create');","\t\t\t\t\tdone();","\t\t\t\t});","\t\t\t});","\t\t});","","\t\tdescribe('reconstitute', () => {","\t\t\tit('should reconstitute a $1', done => {","\t\t\t\tfactory.reconstitute(data, (err, res) => {","\t\t\t\t\texpect(res).toExist('expected factory to reconstitute');","\t\t\t\t\tdone();","\t\t\t\t});","\t\t\t});","\t\t});","\t});","});",""]},"Ctrl Test Setup":{"prefix":"ctrl:test","body":["","'use strict';","","","const expect = require('expect');","const sinon = require('sinon');","const $1Ctrl = require('./$1Ctrl');","const Mocks = require('');","const service = {","\tfindOne(){}","};","/**","* helper: ${TM_FILEPATH}","* mocha --require clarify ./path/to/file.test.js --watch","* istanbul cover --print both node_modules/.bin/_mocha -- ./path/to/file.test.js","* eslint ./path/to/file.test.js --watch","*/","","describe('$1Ctrl', () => {","\tlet sandbox;","\tlet ctrl","\tlet req;","\tlet res;","","\tbefore(() => {","\t\tctrl = new $1Ctrl(service);","\t});","","\tbeforeEach(() => {","\t\tsandbox = sinon.sandbox.create();","\t\treq = Object.assign({}, Mocks.req);","\t\tres = Object.assign({}, Mocks.res);","\t\tsandbox.stub(service);","\t\tsandbox.stub(req);","\t\tsandbox.stub(res);","\t});","","\tafterEach(() => {","\t\tsandbox.restore();","\t});","","\tdescribe('general', () => {","\t\tit('should have an injection static', () => {","\t\t\texpect(Array.isArray($1Ctrl.inject)).toBe(true);","\t\t});","\t});","","\tdescribe('$1 Controller Methods', () => {","","\t\tafterEach(() => {","\t\t\texpect(res.send.called).toBe(true, 'response never sent.');","\t\t});","","\t\tdescribe('findOne', () => {","\t\t\tit('should find a $1', done => {","\t\t\t\treq.params.id = 'foo';","\t\t\t\tservice.findOne.yields(null, {});","\t\t\t\tctrl.findOne(req, res);","\t\t\t\tsetImmediate(() => {","\t\t\t\t\texpect(res.status.calledWith(200)).toBe(true, 'wrong error code.');","\t\t\t\t\tconst data = res.send.args[0][0];","\t\t\t\t\texpect(data).toExist();","\t\t\t\t\tdone();","\t\t\t\t});","\t\t\t});","\t\t});","","\t});","});",""]},"Mongoose Model":{"prefix":"mongoose:model","body":["","'use strict';","","","const mongoose = require('mongoose');","const timestamp = require('mongoose-timestamp');","","const modelName = '$1';","","class ModelFactory {","   static get inject(){","     return [","     ];","   }","","   constructor() {","","   \t// define schema","   \tconst schema = new mongoose.Schema({","\t\t\t});","","\t\t\tschema.plugin(timestamp);","","\t\t\t// register model with mongoose","\t\t\tmongoose.model(modelName, schema);","","\t\t\t// return model instance","\t\t\treturn mongoose.model(modelName);","","   }","}","","module.exports = ModelFactory;",""]}}