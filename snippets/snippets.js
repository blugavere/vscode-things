'use strict';

const Builder = require('./Builder');
const react = require('./react');
const assertions = require('./assertions');
const docs = require('./docs');

module.exports = Object.assign({}, assertions, react, docs, {
	"Route Setup": {
		prefix: 'route',
		body: new Builder().strict().add([
			'const register = (app, injector) => {',
			'',
			'',
			'',
			'module.exports = register;',
			''
		]).build()
	},
	"Unit Test Setup": {
		"prefix": "test",
		"body": new Builder().strict().add([
			"const path = require('path');",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"",
			"const mock = {",
			"};",
			"",
		]).scripts().add([
			"",
			"describe(path.basename(__filename).replace('.test.js', ''), () => {",
			"	let sandbox;",
			"",
			"	before(() => {",
			"",
			"	});",
			"",
			"	after(() => {",
			"",
			"	});",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	it('should pass', () => {",
			"		expect(true).toBe(true);",
			"	});",
			"",
			"	it('should also pass', done => {",
			"		expect(true).toBe(true);",
			"		done();",
			"	});",
			"});",
			""
		]).build()
	},
	"Integration Test Setup": {
		"prefix": "integration:test",
		"body": [
			"",
			"'use strict';",
			"",
			"const path = require('path');",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"const assert = require('assert');",
			"const mongoose = require('mongoose');",
			"",
			"const types = require('../../admin/startup/di/types');",
			"const Mocks = require('../../admin/controllers/base/Mocks');",
			"const chalk = require('chalk');",
			"const app = { set() {} };",
			"const mock = {",
			"};",
			"",
			"/**",
			"* helper: ${TM_FILEPATH}",
			"* mocha --require clarify $2 --watch",
			"* istanbul cover --print both node_modules/.bin/_mocha -- $2",
			"* eslint $2",
			"*/",
			"",
			"describe('$1 Integration Test', () => {",
			"	let sandbox;",
			"	let req = Mocks.req;",
			"	let res = Mocks.res;",
			"	let ctrl;",
			"	let repo;",
			"	let injector;",
			"",
			"	before(() => {",
			"		require('../../models/plugins/autoincr').init();",
			"		require('../../models/loadModels');",
			"		injector = require('../../admin/startup/injector.config').default.configure(app);",
			"		ctrl = injector.get(types.$1Ctrl);",
			"		repo = injector.get(types.$1Repository);",
			"		mongoose.connect('mongodb://localhost/giddy-test');",
			"	});",
			"",
			"	after(() => {",
			"		mongoose.models = {};",
			"		mongoose.modelSchemas = {};",
			"		mongoose.connection.models = {};",
			"		mongoose.disconnect();",
			"	});",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"		sandbox.stub(res);",
			"		sandbox.stub(req);",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	describe('queries', () => {",
			"		it('should be able to find a $1', done => {",
			"			repo.findOne('id', (err, doc) => {",
			"				expect(doc).toExist('expected $1 to exist');",
			"				done();",
			"			});",
			"		});",
			"	});",
			"",
			"	describe('routes', () => {",
			"		afterEach(() => {",
			"			expect(res.send.called).toBe(true, 'res.send never called');",
			"		});",
			"",
			"		it('should do something', done => {",
			"			req.body = {};",
			"			ctrl.method(req, res); //EDIT",
			"			setTimeout(() => {",
			"				expect(res.status.calledWith(200)).toBe(true, 'res.status called with wrong status code');",
			"				done();",
			"			}, 100);",
			"		});",
			"	});",
			"",
			"});",
			""
		]
	},
	"Repository": {
		"prefix": "repository",
		"body": [
			"",
			"'use strict';",
			"",
			"const types = require('../../admin/startup/di/types');",
			"const MongooseRepository = require('../repositories/base/MongooseRepository');",
			"",
			"function populate(queryable) {",
			"    return queryable;",
			"}",
			"",
			"class $1Repository extends MongooseRepository {",
			"    static get inject(){",
			"        return [",
			"            types.$1",
			"        ];",
			"    }",
			"    constructor(model) {",
			"        super(model);",
			"",
			"        this.findOneDetailed = this.findOneDetailed.bind(this);",
			"    }",
			"    findOneDetailed(id, cb) {",
			"        cb();",
			"    }",
			"",
			"}",
			"",
			"module.exports = $1Repository;",
			""
		]
	},
	"Repository Test Setup": {
		"prefix": "repository:test",
		"body": [
			"",
			"'use strict';",
			"",
			"const path = require('path');",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"const _ = require('lodash');",
			"const Mockgoose = require('../repositories/base/Mockgoose');",
			"const Repository = require('./$1Repository');",
			"",
			"/**",
			"* helper: ${TM_FILEPATH}",
			"* mocha --require clarify $2 --watch",
			"* istanbul cover --print both node_modules/.bin/_mocha -- $2",
			"* eslint $2",
			"*/",
			"",
			"describe('$1Repository', () => {",
			"	let sandbox;",
			"	let repo;",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"		for (const i in Mockgoose) {",
			"			sandbox.stub(Mockgoose, i);",
			"		}",
			"		Mockgoose.populate.returns(Mockgoose);",
			"		Mockgoose.lean.returns(Mockgoose);",
			"		repo = new Repository(Mockgoose);",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	describe('general', () => {",
			"		it('should have an injection static', () => {",
			"			expect(Array.isArray(Repository.inject)).toBe(true);",
			"		});",
			"	});",
			"",
			"	describe('$1 business methods', () => {",
			"		it('should pass', () => {",
			"			expect(true).toBe(true);",
			"		});",
			"",
			"		it('should also pass', done => {",
			"			expect(true).toBe(true);",
			"			done();",
			"		});",
			"	});",
			"});",
			""
		]
	},
	"Service": {
		"prefix": "service",
		"body": [
			"",
			"'use strict';",
			"",
			"const types = require('../../admin/startup/di/types');",
			"",
			"class $1Service {",
			"    static get inject(){",
			"        return [",
			"            types.$1Repository",
			"        ];",
			"    }",
			"    constructor(repo) {",
			"        this.repo = repo;",
			"",
			"        this.findOne = this.findOne.bind(this);",
			"    }",
			"    findOne(id, cb) {",
			"        cb();",
			"    }",
			"",
			"}",
			"",
			"module.exports = $1Service;",
			""
		]
	},
	"Service Method": {
		"prefix": "service:test:method",
		"body": [
			"describe('$1', () => {",
			"	it('should $1', done => {",
			"		repo.findOne.yields(null, {});",
			"		service.$1('foo', (err, doc) => {",
			"			expect(err).toNotExist();",
			"			expect(doc).toExist();",
			"			done();",
			"		});",
			"	});",
			"",
			"	it('should fail gracefully', done => {",
			"		repo.findOne.yields({});",
			"		service.$1('foo', err => {",
			"			expect(err).toExist();",
			"			done();",
			"		});",
			"	});",
			"});"
		]
	},
	"Service Test Setup": {
		"prefix": "service:test",
		"body": [
			"",
			"'use strict';",
			"",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"const $1Service = require('./$1Service');",
			"",
			"const repo = Object.assign({}, require('../repositories/base/MockRepo'), {",
			"	findOneDetailed(){}",
			"});",
			"",
			"/**",
			"* helper: ${TM_FILEPATH}",
			"* mocha --require clarify $2 --watch",
			"* istanbul cover --print both node_modules/.bin/_mocha -- $2",
			"* eslint $2",
			"*/",
			"",
			"describe('$1Service', () => {",
			"	let sandbox;",
			"	let service;",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"		sandbox.stub(repo);",
			"		service = new $1Service(repo);",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	describe('general', () => {",
			"		it('should have an injection static', () => {",
			"			expect(Array.isArray($1Service.inject)).toBe(true);",
			"		});",
			"	});",
			"",
			"	describe('$1 Service Methods', () => {",
			"		it('should pass', () => {",
			"			expect(true).toBe(true);",
			"		});",
			"",
			"		it('should also pass', done => {",
			"			expect(true).toBe(true);",
			"			done();",
			"		});",
			"	});",
			"});",
			""
		]
	},
	"Factory": {
		"prefix": "factory",
		"body": [
			"",
			"'use strict';",
			"",
			"const types = require('../../admin/startup/di/types');",
			"",
			"class $1Factory {",
			"    static get inject(){",
			"        return [",
			"            types.$1",
			"        ];",
			"    }",
			"    constructor(Order) {",
			"        this.$1 = $1;",
			"        this.create = this.create.bind(this);",
			"        this.reconstitute = this.reconstitute.bind(this);",
			"    }",
			"    create(order, cb) {",
			"        cb();",
			"    }",
			"    reconstitute(order, cb) {",
			"        cb();",
			"	 }",
			"}",
			"",
			"module.exports = $1Factory;"
		]
	},
	"Factory Test Setup": {
		"prefix": "factory:test",
		"body": new Builder().strict().add([
			"",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"const $1Factory = require('./$1Factory');",
			""
		]).scripts().add([
			"",
			"describe('$1Factory', () => {",
			"	let sandbox;",
			"	let Model = function(){}",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"		factory = new $1Factory(Model);",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	describe('general', () => {",
			"		it('should have an injection static', () => {",
			"			expect(Array.isArray($1Factory.inject)).toBe(true);",
			"		});",
			"	});",
			"",
			"	describe('$1 Factory Methods', () => {",
			"		describe('create', () => {",
			"			it('should create a $1', done => {",
			"				factory.create(data, (err, res) => {",
			"					expect(res).toExist('expected factory to create');",
			"					done();",
			"				});",
			"			});",
			"		});",
			"",
			"		describe('reconstitute', () => {",
			"			it('should reconstitute a $1', done => {",
			"				factory.reconstitute(data, (err, res) => {",
			"					expect(res).toExist('expected factory to reconstitute');",
			"					done();",
			"				});",
			"			});",
			"		});",
			"	});",
			"});",
			""
		]).build()
	},
});