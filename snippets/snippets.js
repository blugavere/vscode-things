'use strict';

const Builder = require('./Builder');
const react = require('./react');
const assertions = require('./assertions');
const docs = require('./docs');

module.exports = Object.assign({}, assertions, react, docs, {
	'Route Setup': {
		prefix: 'route',
		body: new Builder().strict().add([
			'',
			'const types = require(\'\'); // path to types',
			'',
			'const register = (app, injector) => {',
			'	const ctrl = injector.get(types.$1Ctrl);',
			'',
			'	app.get(\'/model\', ctrl.findAll);',
			'};',
			'',
			'module.exports = register;',
			''
		]).build()
	},
	'Unit Test Setup': {
		'prefix': 'test',
		'body': new Builder().strict().add([
			'const path = require(\'path\');',
			'const expect = require(\'expect\');',
			'const sinon = require(\'sinon\');',
			'',
			'const mock = {',
			'};',
			'',
		]).scripts().add([
			'',
			'describe(path.basename(__filename).replace(\'.test.js\', \'\'), () => {',
			'	let sandbox;',
			'',
			'	before(() => {',
			'',
			'	});',
			'',
			'	after(() => {',
			'',
			'	});',
			'',
			'	beforeEach(() => {',
			'		sandbox = sinon.sandbox.create();',
			'	});',
			'',
			'	afterEach(() => {',
			'		sandbox.restore();',
			'	});',
			'',
			'	it(\'should pass\', () => {',
			'		expect(true).toBe(true);',
			'	});',
			'',
			'	it(\'should also pass\', done => {',
			'		expect(true).toBe(true);',
			'		done();',
			'	});',
			'});',
			''
		]).build()
	},
	'Integration Test Setup': {
		'prefix': 'integration:test',
		'body': new Builder().strict().add([
			'const path = require(\'path\');',
			'const expect = require(\'expect\');',
			'const sinon = require(\'sinon\');',
			'const assert = require(\'assert\');',
			'const mongoose = require(\'mongoose\');',
			'',
			'const types = require(\'\');',
			'const Mocks = require(\'\');',
			'const chalk = require(\'chalk\');',
			'const app = { set() {} };',
			'const mock = {',
			'};',
			'',
			'/**',
			'* helper: ${TM_FILEPATH}',
			'* mocha --require clarify $2 --watch',
			'* istanbul cover --print both node_modules/.bin/_mocha -- $2',
			'* eslint $2',
			'*/',
			'',
			'describe(\'$1 Integration Test\', () => {',
			'	let sandbox;',
			'	let req = Mocks.req;',
			'	let res = Mocks.res;',
			'	let ctrl;',
			'	let repo;',
			'	let injector;',
			'',
			'	before(() => {',
			'		require(\'\').init(); //autoincr',
			'		require(\'\'); // model registry',
			'		injector = require(\'\').default.configure(app);',
			'		ctrl = injector.get(types.$1Ctrl);',
			'		repo = injector.get(types.$1Repository);',
			'		mongoose.connect(\'\'); // mongodb connection string',
			'	});',
			'',
			'	after(() => {',
			'		mongoose.models = {};',
			'		mongoose.modelSchemas = {};',
			'		mongoose.connection.models = {};',
			'		mongoose.disconnect();',
			'	});',
			'',
			'	beforeEach(() => {',
			'		sandbox = sinon.sandbox.create();',
			'		sandbox.stub(res);',
			'		sandbox.stub(req);',
			'	});',
			'',
			'	afterEach(() => {',
			'		sandbox.restore();',
			'	});',
			'',
			'	describe(\'queries\', () => {',
			'		it(\'should be able to find a $1\', done => {',
			'			repo.findOne(\'id\', (err, doc) => {',
			'				expect(doc).toExist(\'expected $1 to exist\');',
			'				done();',
			'			});',
			'		});',
			'	});',
			'',
			'	describe(\'routes\', () => {',
			'		afterEach(() => {',
			'			expect(res.send.called).toBe(true, \'res.send never called\');',
			'		});',
			'',
			'		it(\'should do something\', done => {',
			'			req.body = {};',
			'			ctrl.method(req, res); //EDIT',
			'			setTimeout(() => {',
			'				expect(res.status.calledWith(200)).toBe(true, \'res.status called with wrong status code\');',
			'				done();',
			'			}, 100);',
			'		});',
			'	});',
			'',
			'});',
		]).eol().build()
	},
	'Repository': {
		'prefix': 'repository',
		'body': new Builder().strict().add([
			'const types = require(\'\');',
			'const MongooseRepository = require(\'../repositories/base/MongooseRepository\');',
			'',
			'function populate(queryable) {',
			'    return queryable;',
			'}',
			'',
			'class $1Repository extends MongooseRepository {',
			'    static get inject(){',
			'        return [',
			'            types.$1',
			'        ];',
			'    }',
			'    constructor(model) {',
			'        super(model);',
			'',
			'        this.findOneDetailed = this.findOneDetailed.bind(this);',
			'    }',
			'    findOneDetailed(id, cb) {',
			'        cb();',
			'    }',
			'',
			'}',
			'',
			'module.exports = $1Repository;',
			''
		]).eol().build()
	},
	'Repository Test Setup': {
		'prefix': 'repository:test',
		'body': new Builder().strict().add([
			'const path = require(\'path\');',
			'const expect = require(\'expect\');',
			'const sinon = require(\'sinon\');',
			'const _ = require(\'lodash\');',
			'const Mockgoose = require(\'../repositories/base/Mockgoose\');',
			'const Repository = require(\'./$1Repository\');',
			'',
			'/**',
			'* helper: ${TM_FILEPATH}',
			'* mocha --require clarify $2 --watch',
			'* istanbul cover --print both node_modules/.bin/_mocha -- $2',
			'* eslint $2',
			'*/',
			'',
			'describe(\'$1Repository\', () => {',
			'	let sandbox;',
			'	let repo;',
			'',
			'	beforeEach(() => {',
			'		sandbox = sinon.sandbox.create();',
			'		for (const i in Mockgoose) {',
			'			sandbox.stub(Mockgoose, i);',
			'		}',
			'		Mockgoose.populate.returns(Mockgoose);',
			'		Mockgoose.lean.returns(Mockgoose);',
			'		repo = new Repository(Mockgoose);',
			'	});',
			'',
			'	afterEach(() => {',
			'		sandbox.restore();',
			'	});',
			'',
			'	describe(\'general\', () => {',
			'		it(\'should have an injection static\', () => {',
			'			expect(Array.isArray(Repository.inject)).toBe(true);',
			'		});',
			'	});',
			'',
			'	describe(\'$1 business methods\', () => {',
			'		it(\'should pass\', () => {',
			'			expect(true).toBe(true);',
			'		});',
			'',
			'		it(\'should also pass\', done => {',
			'			expect(true).toBe(true);',
			'			done();',
			'		});',
			'	});',
			'});',
		]).eol().build()
	},
	'Service': {
		'prefix': 'service',
		'body': new Builder().strict().add([
			'const types = require(\'\');',
			'',
			'class $1Service {',
			'    static get inject(){',
			'        return [',
			'            types.$1Repository',
			'        ];',
			'    }',
			'    constructor(repo) {',
			'        this.repo = repo;',
			'',
			'        this.findOne = this.findOne.bind(this);',
			'    }',
			'    findOne(id, cb) {',
			'        cb();',
			'    }',
			'',
			'}',
			'',
			'module.exports = $1Service;'
		]).eol().build()
	},
	'Service Method': {
		'prefix': 'service:test:method',
		'body': [
			'describe(\'$1\', () => {',
			'	it(\'should $1\', done => {',
			'		repo.findOne.yields(null, {});',
			'		service.$1(\'foo\', (err, doc) => {',
			'			expect(err).toNotExist();',
			'			expect(doc).toExist();',
			'			done();',
			'		});',
			'	});',
			'',
			'	it(\'should fail gracefully\', done => {',
			'		repo.findOne.yields({});',
			'		service.$1(\'foo\', err => {',
			'			expect(err).toExist();',
			'			done();',
			'		});',
			'	});',
			'});'
		]
	},
	'Service Test Setup': {
		'prefix': 'service:test',
		'body': new Builder().strict().add([
			'const expect = require(\'expect\');',
			'const sinon = require(\'sinon\');',
			'const $1Service = require(\'./$1Service\');',
			'',
			'const repo = Object.assign({}, require(\'../repositories/base/MockRepo\'), {',
			'	findOneDetailed(){}',
			'});',
			'',
			'/**',
			'* helper: ${TM_FILEPATH}',
			'* mocha --require clarify $2 --watch',
			'* istanbul cover --print both node_modules/.bin/_mocha -- $2',
			'* eslint $2',
			'*/',
			'',
			'describe(\'$1Service\', () => {',
			'	let sandbox;',
			'	let service;',
			'',
			'	beforeEach(() => {',
			'		sandbox = sinon.sandbox.create();',
			'		sandbox.stub(repo);',
			'		service = new $1Service(repo);',
			'	});',
			'',
			'	afterEach(() => {',
			'		sandbox.restore();',
			'	});',
			'',
			'	describe(\'general\', () => {',
			'		it(\'should have an injection static\', () => {',
			'			expect(Array.isArray($1Service.inject)).toBe(true);',
			'		});',
			'	});',
			'',
			'	describe(\'$1 Service Methods\', () => {',
			'		it(\'should pass\', () => {',
			'			expect(true).toBe(true);',
			'		});',
			'',
			'		it(\'should also pass\', done => {',
			'			expect(true).toBe(true);',
			'			done();',
			'		});',
			'	});',
			'});',
		]).eol().build()
	},
	'Factory': {
		'prefix': 'factory',
		'body': new Builder().strict().add([
			'const types = require(\'\');',
			'',
			'class $1Factory {',
			'    static get inject(){',
			'        return [',
			'            types.$1',
			'        ];',
			'    }',
			'',
			'    constructor($1) {',
			'        this.$1 = $1;',
			'        this.create = this.create.bind(this);',
			'        this.reconstitute = this.reconstitute.bind(this);',
			'    }',
			'    create(data, cb) {',
			'				const model = Object.assign(new this.$1(), data);',
			'       cb(null, model);',
			'    }',
			'',
			'    reconstitute(data, cb) {',
			'				const model = Object.assign(new this.$1(), data);',
			'       cb(null, model);',
			'	 }',
			'}',
			'',
			'module.exports = $1Factory;'
		]).eol().build()
	},
	'Factory Test Setup': {
		'prefix': 'factory:test',
		'body': new Builder().strict().add([
			'',
			'const expect = require(\'expect\');',
			'const sinon = require(\'sinon\');',
			'const $1Factory = require(\'./$1Factory\');',
			''
		]).scripts().add([
			'',
			'describe(\'$1Factory\', () => {',
			'	let sandbox;',
			'	let factory;',
			'	let data;',
			'	let Model = function(){};',
			'',
			'	beforeEach(() => {',
			'		sandbox = sinon.sandbox.create();',
			'		factory = new $1Factory(Model);',
			'	});',
			'',
			'	afterEach(() => {',
			'		sandbox.restore();',
			'	});',
			'',
			'	describe(\'general\', () => {',
			'		it(\'should have an injection static\', () => {',
			'			expect(Array.isArray($1Factory.inject)).toBe(true);',
			'		});',
			'	});',
			'',
			'	describe(\'$1 Factory Methods\', () => {',
			'		describe(\'create\', () => {',
			'			it(\'should create a $1\', done => {',
			'				factory.create(data, (err, res) => {',
			'					expect(res).toExist(\'expected factory to create\');',
			'					done();',
			'				});',
			'			});',
			'		});',
			'',
			'		describe(\'reconstitute\', () => {',
			'			it(\'should reconstitute a $1\', done => {',
			'				factory.reconstitute(data, (err, res) => {',
			'					expect(res).toExist(\'expected factory to reconstitute\');',
			'					done();',
			'				});',
			'			});',
			'		});',
			'	});',
			'});',
			''
		]).build()
	},
	'Ctrl Test Setup': {
		'prefix': 'ctrl:test',
		'body': new Builder().strict().add([
			'',
			'const expect = require(\'expect\');',
			'const sinon = require(\'sinon\');',
			'const $1Ctrl = require(\'./$1Ctrl\');',
			'const Mocks = require(\'\');',
			'const service = {',
			'	findOne(){}',
			'};',
		]).scripts().add([
			'',
			'describe(\'$1Ctrl\', () => {',
			'	let sandbox;',
			'	let ctrl',
			'	let req;',
			'	let res;',
			'',
			'	before(() => {',
			'		ctrl = new $1Ctrl(service);',
			'	});',
			'',
			'	beforeEach(() => {',
			'		sandbox = sinon.sandbox.create();',
			'		req = Object.assign({}, Mocks.req);',
			'		res = Object.assign({}, Mocks.res);',
			'		sandbox.stub(service);',
			'		sandbox.stub(req);',
			'		sandbox.stub(res);',
			'	});',
			'',
			'	afterEach(() => {',
			'		sandbox.restore();',
			'	});',
			'',
			'	describe(\'general\', () => {',
			'		it(\'should have an injection static\', () => {',
			'			expect(Array.isArray($1Ctrl.inject)).toBe(true);',
			'		});',
			'	});',
			'',
			'	describe(\'$1 Controller Methods\', () => {',
			'',
			'		afterEach(() => {',
			'			expect(res.send.called).toBe(true, \'response never sent.\');',
			'		});',
			'',
			'		describe(\'findOne\', () => {',
			'			it(\'should find a $1\', done => {',
			'				req.params.id = \'foo\';',
			'				service.findOne.yields(null, {});',
			'				ctrl.findOne(req, res);',
			'				setImmediate(() => {',
			'					expect(res.status.calledWith(200)).toBe(true, \'wrong error code.\');',
			'					const data = res.send.args[0][0];',
			'					expect(data).toExist();',
			'					done();',
			'				});',
			'			});',
			'		});',
			'',
			'	});',
			'});',
			''
		]).build()
	},
	'Mongoose Model': {
		prefix: 'mongoose:model',
		body: new Builder().strict().add([
			'',
			'const mongoose = require(\'mongoose\');',
			'const timestamp = require(\'mongoose-timestamp\');',
			'',
			'const modelName = \'$1\';',
			'',
			'class ModelFactory {'])
			.inject()
			.add([
			'',
			'   constructor() {',
			'',
			'   	// define schema',
			'   	const schema = new mongoose.Schema({',
			'			});',
			'',
			'			schema.plugin(timestamp);',
			'',
			'			// register model with mongoose',
			'			mongoose.model(modelName, schema);',
			'',
			'			// return model instance',
			'			return mongoose.model(modelName);',
			'',
			'   }',
			'}',
			'',
			'module.exports = ModelFactory;',
		]).eol().build()
	},
});
