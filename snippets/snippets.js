

module.exports = {
	/*
	 // Place your snippets for JavaScript here. Each snippet is defined under a snippet name and has a prefix, body and 
	 // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	 // $1, $2 for tab stops, ${id} and ${id:label} and ${1:label} for variables. Variables with the same id are connected.
	 // Example:
	 "Print to console": {
		"prefix": "log",
		"body": [
			"console.log('$1');",
			"$2"
		],
		"description": "Log output to console"
	}
	
*/
"create component": {
    "prefix": "component",
    "body": [
        "class $1 extends React.Component {",
        "",
        "   render() {",
        "       return ($2);",
        "   }",
        "",
        "}"
    ]
},
	"test setup": {
		"prefix": "test",
		"body": [
			"",
			"'use strict';",
			"",
			"const path = require('path');",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"",
			"const mock = {",
			"};",
			"",
			"/**",
			"* helper: ${TM_FILEPATH}",
			"* mocha --require clarify $2 --watch",
			"* istanbul cover --print both node_modules/.bin/_mocha -- $2",
			"*/",
			"",
			"describe(path.basename(__filename).replace('.test.js', ''), () => {",
			"	let sandbox;",
			"",
			"	before(() => {",
			"",
			"	});",
			"",
			"	after(() => {",
			"",
			"	});",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	it('should pass', () => {",
			"		expect(true).toBe(true);",
			"	});",
			"",
			"	it('should also pass', done => {",
			"		expect(true).toBe(true);",
			"		done();",
			"	});",
			"});",
			""
		]
	},
	"repository": {
		"prefix": "repository",
		"body": [
			"",
			"'use strict';",
			"",
			"const types = require('../../admin/startup/di/types');",
			"const MongooseRepository = require('../repositories/base/MongooseRepository');",
			"",
			"function populate(queryable) {",
			"    return queryable;",
			"}",
			"",
			"class $1Repository extends MongooseRepository {",
			"    static get inject(){",
			"        return [",
			"            types.$1",
			"        ];",
			"    }",
			"    constructor(model) {",
			"        super(model);",
			"",
			"        this.findOneDetailed = this.findOneDetailed.bind(this);",
			"    }",
			"    findOneDetailed(id, cb) {",
			"        cb();",
			"    }",
			"",
			"}",
			"",
			"module.exports = $1Repository;",
			""
		]
	},
	"Repository Test Setup": {
		"prefix": "repository:test",
		"body": [
			"",
			"'use strict';",
			"",
			"const path = require('path');",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"const _ = require('lodash');",
			"const Mockgoose = require('../repositories/base/Mockgoose');",
			"const Repository = require('./$1Repository');",
			"",
			"/**",
			"* helper: ${TM_FILEPATH}",
			"* mocha --require clarify $2 --watch",
			"* istanbul cover --print both node_modules/.bin/_mocha -- $2",
			"* eslint $2",
			"*/",
			"",
			"describe('$1Repository', () => {",
			"	let sandbox;",
			"	let repo;",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"		for (const i in Mockgoose) {",
			"			sandbox.stub(Mockgoose, i);",
			"		}",
			"		Mockgoose.populate.returns(Mockgoose);",
			"		Mockgoose.lean.returns(Mockgoose);",
			"		repo = new Repository(Mockgoose);",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	describe('general', () => {",
			"		it('should have an injection static', () => {",
			"			expect(Array.isArray(Repository.inject)).toBe(true);",
			"		});",
			"	});",
			"",
			"	describe('$1 business methods', () => {",
			"		it('should pass', () => {",
			"			expect(true).toBe(true);",
			"		});",
			"",
			"		it('should also pass', done => {",
			"			expect(true).toBe(true);",
			"			done();",
			"		});",
			"	});",
			"});",
			""
		]
	},
	"service": {
		"prefix": "service",
		"body": [
			"",
			"'use strict';",
			"",
			"const types = require('../../admin/startup/di/types');",
			"",
			"class $1Service {",
			"    static get inject(){",
			"        return [",
			"            types.$1Repository",
			"        ];",
			"    }",
			"    constructor(repo) {",
			"        this.repo = repo;",
			"",
			"        this.findOne = this.findOne.bind(this);",
			"    }",
			"    findOne(id, cb) {",
			"        cb();",
			"    }",
			"",
			"}",
			"",
			"module.exports = $1Service;",
			""
		]
	},
	"service test": {
		"prefix": "service:test",
		"body": [
			"",
			"'use strict';",
			"",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"const $1Service = require('./$1Service');",
			"",
			"const repo = Object.assign({}, require('../repositories/base/MockRepo'), {",
			"	findOneDetailed(){}",
			"});",
			"",
			"/**",
			"* helper: ${TM_FILEPATH}",
			"* mocha --require clarify $2 --watch",
			"* istanbul cover --print both node_modules/.bin/_mocha -- $2",
			"* eslint $2",
			"*/",
			"",
			"describe('$1Service', () => {",
			"	let sandbox;",
			"	let service;",
			"",
			"	beforeEach(() => {",
			"		sandbox = sinon.sandbox.create();",
			"		sandbox.stub(repo);",
			"		service = new $1Service(repo);",
			"	});",
			"",
			"	afterEach(() => {",
			"		sandbox.restore();",
			"	});",
			"",
			"	describe('general', () => {",
			"		it('should have an injection static', () => {",
			"			expect(Array.isArray($1Service.inject)).toBe(true);",
			"		});",
			"	});",
			"",
			"	describe('$1 Service Methods', () => {",
			"		it('should pass', () => {",
			"			expect(true).toBe(true);",
			"		});",
			"",
			"		it('should also pass', done => {",
			"			expect(true).toBe(true);",
			"			done();",
			"		});",
			"	});",
			"});",
			""
		]
	},
	"factory": {
		"prefix": "factory",
		"body": [
			"",
			"'use strict';",
			"",
			"const types = require('../../admin/startup/di/types');",
			"",
			"class $1Factory {",
			"    static get inject(){",
			"        return [",
			"            types.$1",
			"        ];",
			"    }",
			"    constructor(Order) {",
			"        this.$1 = $1;",
			"        this.create = this.create.bind(this);",
			"        this.reconstitute = this.reconstitute.bind(this);",
			"    }",
			"    create(order, cb) {",
			"        cb();",
			"    }",
			"    reconstitute(order, cb) {",
			"        cb();",
			"	 }",
			"}",
			"",
			"module.exports = $1Factory;"
		]
	},
	"component test": {
		"prefix": "test:component",
		"body": [
			"",
			"'use strict';",
			"",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"const React = require('react');",
			"const shallow = require('enzyme').shallow;",
			"",
			"const setup = () => {",
			"	const props = {",
			"	//define props here",
			"	};",
			" return shallow(<Component {...props} />);",
			"};",
			"",
			"describe('<Component />', () => {",
			"",
			"let component",
			"",
			"beforeEach(() => {",
			"	component = setup();",
			"});",
			"",
			"describe('Component Feature', () => {",
			"",
			"	it('should pass', () => {",
			"		expect(true).toBe(true);",
			"	});",
			"",
			"	it('should also pass', done => {",
			"		expect(true).toBe(true);",
			"		done();",
			"	});",
			"",
			"});",
			"",
			"});",
			"",
			"// examples: ",
			"// component.find(DialogActions).childAt(0).simulate('click');",
			"// expect(wrapper.find(DialogActions).childAt(1).childAt(0).text()).toEqual('Cancel');",
			"// expect(component.find(DialogTitle).childAt(0).text()).toEqual('foo');"
		]
	},
	"actions test": {
		"prefix": "test:actions",
		"body": [
			"",
			"const expect = require('expect');",
			"const sinon = require('sinon');",
			"import * as actions from './actions';",
			"import * as types from './constants';",
			"import configureMockStore from 'redux-mock-store';",
			"import thunk from 'redux-thunk';",
			"",
			"const middlewares = [thunk];",
			"const mockStore = configureMockStore(middlewares);",
			"",
			"",
			"describe('Component Actions', () => {",
			"	let store;",
			"",
			"	before(() => {",
			"	store = mockStore();",
			"	});",
			"",
			"	after(() => {",
			"",
			"	});",
			"",
			"	beforeEach(() => {",
			"",
			"	});",
			"",
			"	beforeEach(() => {",
			"		store.clearActions();",
			"	});",
			"",
			"	describe('Component Feature', () => {",
			"",
			"		it('should pass', () => {",
			"			expect(true).toBe(true);",
			"		});",
			"",
			"		it('should also pass', done => {",
			"			expect(true).toBe(true);",
			"			done();",
			"		});",
			"",
			"	});",
			"",
			"});",
			""
		]
	}
}